/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : imebra
 #	author : miyako
 #	12/06/26
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <memory>
#include <list>

#include "imebra/include/imebra.h"

using namespace puntoexe;
using namespace puntoexe::imebra;

void PluginMain(int32_t selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (int32_t pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
			// --- DICOM
			
		case 1 :
			DICOM_GET_DATA(pResult, pParams);
			break;
			
		case 2 :
			DICOM_Write_jpeg_file(pResult, pParams);
			break;
			
	}
}

// ------------------------------------- DICOM ------------------------------------

#if VERSIONMAC
void _copyPath(C_TEXT *t, std::string *p){
	
	NSString *str = t->copyUTF16String();
	NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
	
	if(u){
		NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
		CFIndex size = CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)path);
		std::vector<uint8_t> buf(size);		
		[path getFileSystemRepresentation:(char *)&buf[0] maxLength:size];
		*p = std::string((char *)&buf[0]);
		[path release];
		[u release];
	}	
	
}
#else
void _copyPath(C_TEXT *t, std::wstring *p){
	
	*p = std::wstring((wchar_t *)t->getUTF16StringPtr());		
	
}
#endif

void _copyString(std::wstring *p, C_TEXT *t){
#if VERSIONMAC	
	iconv_t conv_desc = iconv_open("UTF-8", UTF32NATIVE);	
	
	if ((size_t)conv_desc != (size_t) -1){
		
		const char *inData = (const char *)p->c_str();		
		size_t inDataLen = (size_t)p->length() * sizeof(wchar_t);
		size_t outDataLen = (size_t)(p->length() * 4) + 1;			
		
		char *outData = (char *)calloc(outDataLen, 1);
		char *outDataPtr = outData;			
		
		size_t iconv_value;
		
		iconv_value = iconv (conv_desc, &inData, &inDataLen, &outData, &outDataLen);
		
		if (!iconv_value){
			t->setUTF8String((const uint8_t *)outDataPtr, strlen(outDataPtr));		
		}		
		
		free(outDataPtr);	
		iconv_close (conv_desc);	
	}	
#else
	t->setUTF16String((const PA_Unichar*)p->c_str(), (uint32_t)p->length());
#endif	
}

void DICOM_GET_DATA(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_LONGINT Param2;
	ARRAY_LONGINT Param3;
	ARRAY_LONGINT Param4;
	ARRAY_TEXT Param5;
	ARRAY_TEXT Param6;
	
	Param2.setSize(1);
	Param3.setSize(1);
	Param4.setSize(1);
	Param5.setSize(1);
	Param6.setSize(1);	
	
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);

	ustring	filePath;
	
	_copyPath(&Param1, &filePath);
		
	ptr<stream> inputStream(new stream);
	inputStream->openFile(filePath.c_str(), std::ios_base::in);
	
	ptr<streamReader> reader(new streamReader(inputStream));
	ptr<dataSet> inputDataSet = imebra::codecs::codecFactory::getCodecFactory()->load(reader);
	
	ptr<dataCollectionIterator<dataGroup> > pGroupIterator(inputDataSet->getDataIterator());
	dicomDictionary *defaultDictionary = imebra::dicomDictionary::getDicomDictionary();
	
	for(pGroupIterator->reset(); pGroupIterator->isValid(); pGroupIterator->incIterator())
	{
		ptr<dataGroup> pGroup(pGroupIterator->getData());
		ptr<dataCollectionIterator<data> > pTagIterator(pGroup->getDataIterator());
		
		for(pTagIterator->reset(); pTagIterator->isValid(); pTagIterator->incIterator())
		{
			
			if(pTagIterator->getId() == 0) continue;
			
			ptr<data> pTag(pTagIterator->getData());
			
			imbxUint16 tagId(pTagIterator->getId());
			imbxUint16 groupId(pGroupIterator->getId());				
			imbxUint16 groupOrder(pGroupIterator->getOrder());	
			
			if(groupId <=40){
			
				ptr<handlers::dataHandler> h = inputDataSet->getDataHandler(groupId, groupOrder, tagId, 0L, false);
				
				if(h!= 0){
					imbxUint32 elementNumber = 0;
					while (h->pointerIsValid(elementNumber)) {
						
						std::wstring tagValue = inputDataSet->getUnicodeString(groupId, groupOrder, tagId, elementNumber);
						std::wstring tagName = defaultDictionary->getTagName(groupId, tagId);
						
						C_TEXT n, v;
						
						_copyString(&tagValue, &v);
						_copyString(&tagName, &n);	
						
						Param2.appendIntValue(groupId);
						Param3.appendIntValue(groupOrder);	
						Param4.appendIntValue(tagId);					
						Param5.appendUTF16String(n.getUTF16StringPtr(), n.getUTF16Length());
						Param6.appendUTF16String(v.getUTF16StringPtr(), v.getUTF16Length());	
						
						elementNumber++;
					}
				}				
			}
		}		
	}	
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
	
	returnValue.setReturn(pResult);
}

void DICOM_Write_jpeg_file(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	ustring	filePath;
	_copyPath(&Param1, &filePath);

	ustring	jpegPath;
	_copyPath(&Param2, &jpegPath);
	
	// Separate the extension from the file name
	ustring extension;
	size_t dotPos(jpegPath.rfind(dotChar));
	if(dotPos != jpegPath.npos)
	{
		extension = jpegPath.substr(dotPos);
		jpegPath.erase(dotPos);
	}
	else
	{
		extension = jpegExtension;
	}	
	
	size_t framesCount(0);
	ptr<dataSet> loadedDataSet;
	
	try
	{
		// Open the file containing the dicom dataset
		ptr<puntoexe::stream> inputStream(new puntoexe::stream);
		inputStream->openFile(filePath.c_str(), std::ios_base::in);		
		
		// Connect a stream reader to the dicom stream. Several stream reader
		//  can share the same stream
		ptr<puntoexe::streamReader> reader(new streamReader(inputStream));
		
		// Get a codec factory and let it use the right codec to create a dataset
		//  from the input stream
		ptr<codecs::codecFactory> codecsFactory(codecs::codecFactory::getCodecFactory());
		loadedDataSet = codecsFactory->load(reader, 2048);
		
		// Get the first image. We use it in case there isn't any presentation VOI/LUT
		//  and we have to calculate the optimal one
		ptr<image> dataSetImage(loadedDataSet->getImage(0));
		imbxUint32 width, height;
		dataSetImage->getSize(&width, &height);
		
		// Build the transforms chain
		ptr<transforms::transformsChain> chain(new transforms::transformsChain);
		
		chain->addTransform(new transforms::modalityVOILUT(loadedDataSet));
		
		ptr<transforms::colorTransforms::colorTransformsFactory> colorFactory(transforms::colorTransforms::colorTransformsFactory::getColorTransformsFactory());
		if(colorFactory->isMonochrome(dataSetImage->getColorSpace()))
		{
			ptr<transforms::VOILUT> presentationVOILUT(new transforms::VOILUT(loadedDataSet));
			imbxUint32 firstVOILUTID(presentationVOILUT->getVOILUTId(0));
			if(firstVOILUTID != 0)
			{
				presentationVOILUT->setVOILUT(firstVOILUTID);
				chain->addTransform((presentationVOILUT));
			}
			else
			{
				// Calculate optimal VOI/LUT
				imbxUint32 rowSize, channelPixelSize, channelsNumber;
				ptr<handlers::dataHandlerNumericBase> imagePixels(dataSetImage->getDataHandler(false, &rowSize, &channelPixelSize, &channelsNumber));
				imbxInt32 minValue, maxValue;
				minValue = maxValue = imagePixels->getSignedLong(0);
				imbxUint32 numPixels(width * height);
				for(imbxUint32 scanPixels(1); scanPixels != numPixels; ++scanPixels)
				{
					imbxInt32 value(imagePixels->getSignedLong(scanPixels));
					if(value > maxValue)
					{
						maxValue = value;
					}
					else if(value < minValue)
					{
						minValue = value;
					}
				}
				presentationVOILUT->setCenterWidth((maxValue - minValue) / 2 + minValue, maxValue - minValue);
				chain->addTransform((presentationVOILUT));
			}
		}
		
		// Color transform to YCrCb
		ptr<transforms::colorTransforms::colorTransform> colorTransform(colorFactory->getTransform(loadedDataSet->getUnicodeString(0x0028, 0x0, 0x0004, 0x0), L"YBR_FULL"));
		if(colorTransform != 0)
		{
			chain->addTransform((colorTransform));
		}
		
		ptr<image> finalImage(new image);
		finalImage->create(width, height, image::depthU8, L"YBR_FULL", 7);
		
		// Scan through the frames
		for(imbxUint32 frameNumber(0); ; ++frameNumber)
		{
			PA_YieldAbsolute();
			
			if(frameNumber != 0)
			{
				dataSetImage = loadedDataSet->getImage(frameNumber);
			}
			
			
			if(chain->isEmpty() && dataSetImage->getDepth() != finalImage->getDepth() && dataSetImage->getHighBit() != finalImage->getHighBit())
			{
				chain->addTransform(new transforms::transformHighBit);
			}
			
			if(!chain->isEmpty())
			{
				chain->runTransform(dataSetImage, 0, 0, width, height, finalImage, 0, 0);
			}
			else
			{
				finalImage = dataSetImage;
			}
			
			// Open a stream for the jpeg
			const std::wstring jpegTransferSyntax(L"1.2.840.10008.1.2.4.50");
		
			ustringstream jpegFileName;
			jpegFileName << jpegPath;
			
			if(frameNumber != 0)
			{
				jpegFileName << underScore << frameNumber;
			}
			
			jpegFileName << extension;
			ptr<puntoexe::stream> jpegStream(new puntoexe::stream);
			jpegStream->openFile(jpegFileName.str(), std::ios_base::out | std::ios_base::trunc);
			ptr<puntoexe::streamWriter> jpegWriter(new streamWriter(jpegStream));
			ptr<codecs::codec> outputCodec(codecsFactory->getCodec(jpegTransferSyntax));
			
			// Write the jpeg image to the stream
			outputCodec->setImage(jpegWriter, 
								  finalImage, 
								  jpegTransferSyntax, 
								  codecs::codec::veryHigh,
								  "OB", 8, false, false, false, false);
			
			++framesCount;
		}
		returnValue.setIntValue(1);
	}
	catch(...)
	{

	}

	returnValue.setReturn(pResult);
}